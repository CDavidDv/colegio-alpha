---
import "../styles/global.css";


---

<!doctype html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>Colegio Alpha - Educación de Excelencia en Pachuca</title>
		<meta name="description" content="Colegio Alpha de Pachuca - Educación integral con metodología STEAM, inglés intensivo y formación en valores para kinder, primaria y secundaria." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@200..700&display=swap" rel="stylesheet">
	</head>
	<body class="relative overflow-x-hidden overflow-y-auto">
		<!-- Figuras geométricas animadas de fondo -->
		
		<div class=""></div>
		
		
		<slot />
	</body>
</html>

<style>
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}

	
</style>

<script>
  
// Colores definidos
const colors: string[] = [
  "#67BC29", // Verde logo
  "#01A8B7", // Azul logo y STEAM
  "#97BE12", // Verde STEAM
  "#E4E41A", // Amarillo STEAM
  "#FF7300", // Naranja STEAM
  "#01A8B7"  // Azul claro STEAM
];

const shapes: string[] = ["ball", "triangle", "square", "hexagon"];
const numShapes = 100;
const shapeElements: HTMLElement[] = [];
const shapeData: Map<HTMLElement, {x: number, y: number, vx: number, vy: number, size: number, rotation: number, rotationSpeed: number}> = new Map();

// Variables para el mouse
let mouseX = 0;
let mouseY = 0;
let isMouseMoving = false;
let mouseTimeout: number;

function randomBetween(a: number, b: number): number {
  return a + Math.random() * (b - a);
}

function getPageSize() {
  const body = document.body;
  const html = document.documentElement;
  const width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
  const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
  return { width, height };
}

// Función para obtener la posición del footer
function getFooterPosition() {
  const footer = document.querySelector('footer');
  if (footer) {
    const rect = footer.getBoundingClientRect();
    return {
      top: rect.top + window.scrollY,
      bottom: rect.bottom + window.scrollY,
      height: rect.height
    };
  }
  return null;
}

// Función para obtener el límite inferior seguro (antes del footer)
function getSafeBottomLimit() {
  const footerPos = getFooterPosition();
  if (footerPos) {
    // Establecer límite 100px antes del footer
    return footerPos.top + 50;
  }
  // Si no hay footer, usar el viewport height
  return window.innerHeight;
}

// Función para calcular la distancia entre dos puntos
function getDistance(x1: number, y1: number, x2: number, y2: number): number {
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

// Función para aplicar repulsión del mouse
function applyMouseRepulsion(shape: HTMLElement, data: any) {
  if (!isMouseMoving) return;
  
  const distance = getDistance(mouseX, mouseY, data.x + data.size * 8, data.y + data.size * 8);
  const repulsionRadius = 150; // Radio de influencia del mouse
  const maxForce = 3; // Fuerza máxima de repulsión
  
  if (distance < repulsionRadius && distance > 0) {
    // Calcular dirección de repulsión
    const dx = data.x + data.size * 8 - mouseX;
    const dy = data.y + data.size * 8 - mouseY;
    
    // Normalizar y aplicar fuerza
    const force = Math.max(0, (repulsionRadius - distance) / repulsionRadius) * maxForce;
    const normalizedDx = dx / distance;
    const normalizedDy = dy / distance;
    
    // Aplicar velocidad de repulsión
    data.vx += normalizedDx * force * 0.1;
    data.vy += normalizedDy * force * 0.1;
    
    // Limitar velocidad máxima
    const maxSpeed = 5;
    data.vx = Math.max(-maxSpeed, Math.min(maxSpeed, data.vx));
    data.vy = Math.max(-maxSpeed, Math.min(maxSpeed, data.vy));
  }
}

function createShape(): HTMLElement {
  const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
  const color = colors[Math.floor(Math.random() * colors.length)];
  const size = randomBetween(2, 5); // em
  const { width } = getPageSize();
  const safeBottom = getSafeBottomLimit();
  const left = randomBetween(0, width - size * 16); // px
  const top = randomBetween(0, safeBottom - size * 16); // px - respetar límite seguro

  const el = document.createElement("div");
  el.classList.add("animated-shape", shapeType, "absolute");
  el.style.left = `${left}px`;
  el.style.top = `${top}px`;
  el.style.width = `${size}em`;
  el.style.height = `${size}em`;
  el.style.opacity = "0";
  el.style.transition = "opacity 1.2s";
  el.style.zIndex = "-10"; // Asegurar que estén detrás de todo

  // Estilos por figura
  if (shapeType === "ball") {
    el.style.background = color;
    el.style.borderRadius = "50%";
  } else if (shapeType === "triangle") {
    el.style.width = "0";
    el.style.height = "0";
    el.style.borderLeft = `${size/2}em solid transparent`;
    el.style.borderRight = `${size/2}em solid transparent`;
    el.style.borderBottom = `${size}em solid ${color}`;
    el.style.background = "none";
  } else if (shapeType === "square") {
    el.style.background = color;
    el.style.borderRadius = "0.5em";
    el.style.boxShadow = `0 0 26px 2px ${color}55`;
  } else if (shapeType === "hexagon") {
    el.style.background = color;
    el.style.clipPath = "polygon(25% 6.7%, 75% 6.7%, 100% 50%, 75% 93.3%, 25% 93.3%, 0% 50%)";
    el.style.boxShadow = `0 0 16px 2px ${color}55`;
  }

  // Datos de movimiento
  const vx = randomBetween(-2, 2); // velocidad X
  const vy = randomBetween(-2, 2); // velocidad Y
  const rotationSpeed = randomBetween(-3, 3); // velocidad de rotación
  
  shapeData.set(el, {
    x: left,
    y: top,
    vx: vx,
    vy: vy,
    size: size,
    rotation: 0,
    rotationSpeed: rotationSpeed
  });

  document.body.appendChild(el);
  shapeElements.push(el);
  return el;
}

// Detectar colisiones entre dos figuras
function checkCollision(shape1: HTMLElement, shape2: HTMLElement): boolean {
  const data1 = shapeData.get(shape1);
  const data2 = shapeData.get(shape2);
  
  if (!data1 || !data2) return false;
  
  const distance = Math.sqrt(
    Math.pow(data1.x - data2.x, 2) + 
    Math.pow(data1.y - data2.y, 2)
  );
  
  const minDistance = (data1.size + data2.size) * 8; // em a px aproximado
  
  return distance < minDistance;
}

// Detectar colisión con el footer
function checkFooterCollision(shape: HTMLElement): boolean {
  const data = shapeData.get(shape);
  if (!data) return false;
  
  const footerPos = getFooterPosition();
  if (!footerPos) return false;
  
  // Verificar si la figura está tocando o pasando el área del footer
  const shapeBottom = data.y + data.size * 16;
  return shapeBottom >= footerPos.top + 50;
}

// Manejar colisión entre dos figuras
function handleCollision(shape1: HTMLElement, shape2: HTMLElement) {
  const data1 = shapeData.get(shape1);
  const data2 = shapeData.get(shape2);
  
  if (!data1 || !data2) return;
  
  // Cambiar direcciones de movimiento
  data1.vx = -data1.vx;
  data1.vy = -data1.vy;
  data2.vx = -data2.vx;
  data2.vy = -data2.vy;
  
  // Cambiar dirección de rotación
  data1.rotationSpeed = -data1.rotationSpeed;
  data2.rotationSpeed = -data2.rotationSpeed;

  // Separar las figuras ligeramente para evitar que se queden pegadas
  const dx = data1.x - data2.x;
  const dy = data1.y - data2.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const minDist = (data1.size + data2.size) * 8;
  const overlap = minDist - dist;
  if (overlap > 0) {
    // Mover cada figura la mitad de la distancia de separación necesaria
    const moveX = (dx / dist) * (overlap / 2);
    const moveY = (dy / dist) * (overlap / 2);
    data1.x += moveX;
    data1.y += moveY;
    data2.x -= moveX;
    data2.y -= moveY;
  }
}

// Animar figuras con física
function animateShapes() {
  const { width } = getPageSize();
  const safeBottom = getSafeBottomLimit();
  
  for (let i = shapeElements.length - 1; i >= 0; i--) {
    const shape = shapeElements[i];
    const data = shapeData.get(shape);
    if (!data) continue;
    
    // Aplicar repulsión del mouse
    applyMouseRepulsion(shape, data);
    
    // Verificar colisión con footer
    if (checkFooterCollision(shape)) {
      shape.remove();
      shapeElements.splice(i, 1);
      shapeData.delete(shape);
      const newShape = createShape();
      animateShape(newShape);
      continue;
    }
    
    // Actualizar posición
    data.x += data.vx;
    data.y += data.vy;
    
    // Desaparecer si sale por los lados (horizontal)
    if (data.x < -data.size * 16 || data.x > width) {
      shape.remove();
      shapeElements.splice(i, 1);
      shapeData.delete(shape);
      const newShape = createShape();
      animateShape(newShape);
      continue;
    }
    
    // Rebotar en bordes superior/inferior (vertical) - CON LÍMITE SEGURO
    if (data.y <= 0) {
      data.vy = Math.abs(data.vy); // Forzar dirección hacia abajo
      data.y = 0;
      data.rotationSpeed = -data.rotationSpeed;
    }
    
    // Límite inferior más estricto - antes del footer
    if (data.y >= safeBottom - data.size * 16) {
      data.vy = -Math.abs(data.vy); // Forzar dirección hacia arriba
      data.y = safeBottom - data.size * 16;
      data.rotationSpeed = -data.rotationSpeed;
    }
    
    // Asegurar que nunca salgan de los límites seguros
    data.y = Math.max(0, Math.min(safeBottom - data.size * 16, data.y));
    
    // Actualizar rotación
    data.rotation += data.rotationSpeed;
    
    // Aplicar posición y rotación
    shape.style.left = `${data.x}px`;
    shape.style.top = `${data.y}px`;
    shape.style.transform = `rotate(${data.rotation}deg)`;
  }
  
  // Detectar colisiones
  for (let i = 0; i < shapeElements.length; i++) {
    for (let j = i + 1; j < shapeElements.length; j++) {
      if (checkCollision(shapeElements[i], shapeElements[j])) {
        handleCollision(shapeElements[i], shapeElements[j]);
      }
    }
  }
}

function animateShape(el: HTMLElement) {
  // Aparecer
  setTimeout(() => {
    el.style.opacity = "0.38";
  }, randomBetween(100, 1200));
}

// Event listeners para el mouse
document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  isMouseMoving = true;
  
  // Limpiar timeout anterior
  if (mouseTimeout) {
    clearTimeout(mouseTimeout);
  }
  
  // Desactivar repulsión después de 100ms sin movimiento
  mouseTimeout = window.setTimeout(() => {
    isMouseMoving = false;
  }, 100);
});

// Inicializar
for (let i = 0; i < numShapes; i++) {
  const el = createShape();
  animateShape(el);
}

// Loop de animación
setInterval(animateShapes, 50); // 20 FPS para movimiento suave
</script>